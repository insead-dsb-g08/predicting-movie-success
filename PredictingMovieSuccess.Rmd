---
title: "Predictability and Planning for Large Budget Movie Projects"
author: "EA Group 8"
date: "June 12, 2019"
output:
  html_document: default
  pdf_document: default
theme: leonids
---

# {.tabset .tabset-fade}
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#Business Problem

Large production houses spend millions of dollars upfront to produce movies and only see the relative success or failure many months later. This means that unlike many other businesses, they are not able to pilot or test their product with smaller budgets and so have higher risk. Given this scenario, they need to be able optimize their initial spends by choosing the right combination of factors (genre, actors, director, timing of release etc) or, if given a certain combination of factors (e.g. genre, actors and director), need to be able to make decisions on budget and timing to give the movie the largest chance of success. 


#Business Solution Process

We use a database of 5000 movies on the [Kaggle](https://www.kaggle.com/tmdb/tmdb-movie-metadata) to develop predictive models for movie production houses. By using **logistic regression** and **classification models**, we will develop models that can address the following questions:
* Which factors have the largest impact on a movie’s revenue?
* Given a certain combination of factors, how much should a production house spend to ensure a movie is a ‘success’? We will define measures of success.
* If a production house increases budget by x% for a certain genre, will they increase the chances of success of the movie? By how much?
* What time of the year should a production house release a movie and does this differ by genre?

#Packages Required

To begin, we have used the following R packages installed:

```{r message = FALSE, warning = FALSE}
#Loading the required packages
library(readr)
library(jsonlite)
library(tidyr)
library(dplyr)
library(DT)
library(knitr)
```

##Descriptive Statistics  {.tabset .tabset-fade}

####Data Source


The original dataset is obtained from [Kaggle](https://www.kaggle.com/tmdb/tmdb-movie-metadata/data). 
We have downloaded the dataset from this source and hosted in our group [GitHub profile](https://github.com/insead-dsb-g08/predicting-movie-success). 

####Data Description
The TMDB dataset was generated from The Movie Database API. It has a set of total 20 columns which are factors that potentially affect the success of the movies. These factors could be potentially grouped into the following categories:

* **Financial** includes columns such as "budget" and "revenue"
* **Perception** includes columns such as "votes","average rating" etc.
* **production** includes columns such as "production countries", "released date", "genre", "production house","languages" etc.


####Data Importing

#####Fetching the Data from GitHub
We perform the data importing from the github profile where we have hosted the data. The url for the data is set to the variable `url` and the data is read into the object `df` 

```{r message = FALSE, warning = FALSE}
#URL to read the data from
url <- "https://raw.githubusercontent.com/insead-dsb-g08/predicting-movie-success/master/tmdb_5000_movies.csv"
#Reading the csv file from the URL
movies <- read_csv(url,col_names = TRUE,na = "NA")
#Preview of the data dimensions and column names
dim(movies)
#Examining the column names in the dataset
colnames(movies)
```



####Dataset Structure

When we examine the structure of the dataset, we find that the columns can be in any of the following datatypes:

* Interger
* Numeric
* Character
* Date

We also find that even though some columns have a class as `chr`, they are actually in JSON format which needs to be converted to columns with one of the base r datatypes.

####Data Cleaning

#####Removing Duplicates
We first want to remove the duplicate values (if any) from the dataset. We do this by checking if there were two rows in the dataset that have the same movie title.

```{r }
movies <- movies[!duplicated(movies$title), ]
```

The de-duplicated dataset has the following dimensions:
```{r }
dim(movies)
```


#####Converting all the JSON columns to dataframes

As the dataset contains columns with data in the JSON format. We need to convert these columns to the base datatypes in r so that we can perform analysis.

Following are the columns found to be in JSON format:

* Genres: id, name
* Keywords: id, name
* Production Companies: name, id
* Production Countries: iso_3166_1, name
* Spoken Languages: iso_639_1, name

We first convert each of these columns into separate dataframes.Finally we have 5 new data frames which can then be merged with our base `movies` dataset.

```{r}
#Takes in the dataframe and column name to be trnasformed
json_to_df <- function(df, column){
  column_1 <- df[apply(df[,column],1,nchar)>2,]  #Checks if there is an entry
   
  list_1 <- lapply(column_1[[column]], fromJSON) #Converts the JSON to a list
  values <- data.frame(unlist(lapply(list_1, function(x) paste(x$name,collapse = ",")))) #Collapsing all the values of the list as a key value pair
  
  final_df <- cbind(column_1$id, column_1$title, values) #new data frame with the key and values a s columns
  names(final_df)  <- c("id", "title", column)
  return(final_df)
  
}
```

We then Call the json_to_df() to generate the dataframes for all the JSON Columns.

```{r }
genres_df <- json_to_df(movies, "genres")
keywords_df <- json_to_df(movies, "keywords")
prod_cntry_df <- json_to_df(movies, "production_countries")
prod_cmpny_df <- json_to_df(movies, "production_companies")
spoken_lang_df <- json_to_df(movies, "spoken_languages")
```



#####Merging the dataset
After we have created them as separate dataframes, we combine all these dataframes with the `movies` dataframe to get the final dataset which we will be used for the analysis

For this, we first remove the JSON columns present in the `movies` dataset and then combine the new columns we have created for all the JSON columns

```{r warning = FALSE}
#Subset the movies dataframe by removing the JSON columns
movies_1 <- subset(movies, select =  -c(genres,keywords,production_companies, production_countries,spoken_languages))
#Join the columns from all the generated dataframes from previous step
movies_new <- movies_1 %>%
  full_join(genres_df, by = c("id", "title")) %>%
  full_join(keywords_df, by = c("id", "title")) %>%
  full_join(prod_cntry_df, by = c("id", "title")) %>%
  full_join(prod_cmpny_df, by = c("id", "title")) %>%
  full_join(spoken_lang_df, by = c("id", "title"))
#Have a look at the final dataset
glimpse(movies_new)
size <- dim(movies_new)
```

There are `r size[1]` observations and `r size[2]` columns.

#####**Checking for Missing values**

It's essential to check if there are any missing values in the dataset. 

```{r }
complete_data <- sum(complete.cases(movies_new))
```

As there are `r complete_data` rows with no missing data in the dataset, We do not remove any of the missing values for now. We will look at each column separately and see if we can perform any imputations (if required) while performing the analysis.

####Data Preview
The table below is the preview of the final dataset. We have printed the first 20 rows of the dataset. 

Each row corresponds to a movie and each column is a feature corresponding to the movie.

```{r}
movies_new <- select(movies_new, title, everything())
datatable(head(movies_new,20))
```

####Summary of Data

The final dataset after performing data cleaning has the following columns. The class of each of the column is also presented below.

```{r warning = FALSE}
col <- data.frame(sapply(movies_new, class)) #Gettting the class of each column
Row_names <- rownames(col) #Getting the row names which ae the columns of our dataset
class <- col[,1] 
Data_types <- cbind(Column = Row_names, Class = as.character(class)) 
Data_types <- Data_types[2:nrow(Data_types),] #Removing the first entry alone because it is for the row number
kable(Data_types) #Displays the table as shown below
```

